
还是多注意细节问题！！！暂时没啥别的大问题

tarjan 和 欧拉序-RMQ 法求 LCA都可以这么想，假设已知他们的 lca，那么以 lca 为根的这棵树，两个点 u 和 v 都是它的子节点，那么根据 dfs 的定义，必定会先访问完以 lca 为根节点的这课子树，
再去访问 lca 的兄弟结点的子树或者 lca 的祖先结点，那么对于 欧拉序-RMQ 算法来说，两个节点 u 和 v 中的欧拉序序列，dfs 肯定会先访问 u 所在的子树，然后欧拉序记录到 lca ，然后再去访问 v 所在子树
tarjan 算法也是如此，u 结点访问完并到 lca 上，然后访问 v 结点的时候直接得到了 lca。这都很好理解，然后 u 和 v 中某个点就是他们的 lca 的时候也一样，只不过是遍历某个点的时候发现另一个点依存在它身上


树上任意两个结点 u,v 添加一条附加边可以成一个 u -> lca(u,v) -> v -> u 的环


- 树上倍增：
注意一些 fa 数组的维护，多组输入记得 memset fa 数组，根节点的 dep 和 fa 不用维护，也记得不要维护，避免一些小错误，然后 dfs 的时候写的时候脑子清楚点，眼睛瞪大点，不要出小错误



- tarjan：
如果询问次数过多，注意用来记录答案的数组的空间，可能会爆空间



- 欧拉序-RMQ：
欧拉序是一个 2*n-1 长度的序列，可以这么想，每个点入度一共 +n，然后除了根节点外其他所有点都回溯一次，加上 n-1，所以一共 2*n-1 个

对于每个点，只要记录它第一次出现的时间即可，不用浪费空间再记录什么最后一次出现什么什么的，然后求 lca 的时候在讨论两个点在区间的哪边哪边
因为：
1.首先，不管怎样，通过只关注两个点第一次出现的时间点得到的中间序列的最小深度的结点一定是 lca，和这个没啥好说的，一颗子树的遍历
2.然后在st表中不管区间大小多大都是 O(1) 的查询，那么我们就不用管区间的长度了，无脑上就完事了

欧拉序转RMQ后，st表记录的不是最小深度！！而是最小深度的结点下标！！，不然每次都要在从 u 和 v 之间遍历那个深度等于 st 查询结果的，很傻
