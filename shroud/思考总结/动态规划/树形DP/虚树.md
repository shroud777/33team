链接推荐：- https://www.cnblogs.com/zwfymqz/p/9175152.html

定义：对于一棵 n 个结点的树 T，建立一棵新的树 T'，使得总结点树最少并包含指定的几个结点和他们的LCA
通俗的说，就是根据题意保留有用点，重新建一棵树（有用点指的是关键点和他们的LCA），这样多组询问就可以避免每次 O(n) 遍历一整棵树了

构造：首先预处理出树上结点的 dfs序，然后用一个单调栈维护建树，为什么是一个单调栈呢，因为过程中要始终保持栈内序列是树上的一条链
对于每次插入的结点 x，我们先求出 ance=lca(x,stack.top())，如果 ance==stack.top()，说明新节点在上一结点的子树中，入栈即可
如果 ance!=stack.top()，那么说明 ance 是别的子树中的结点，那么说明 ance->x 这条链已经确定了，不用更改了，我们边出栈边建边即可
并且我们不断出栈直到栈顶第二个元素的 dfs序 < ance 的 dfs序，然后我们判断栈顶是不是 ance，如果是，我们只需要将新节点入栈即可，反之，说明 ance 之前没入过栈，我们现在重新补进去
在 ance->stack.top() 建一条边，然后出栈，再把 ance 入栈即可，然后再把 x 入栈
不断重复这个过程，我们即可建立出虚树

void insert(int x){
	if(tp==1){
		st[++tp]=x;
		return;
	} 
	int ance=lca(x,st[tp]);
	if(ance==st[tp]){
    st[++tp]=x;
     return;
  }
	while(dfn[st[tp-1]]>=dfn[ance]&&tp>1)  g[st[tp-1]].pb(st[tp]),--tp;
	if(ance!=st[tp]) g[ance].pb(st[tp]),st[tp]=ance;
	st[++tp]=x;
}
