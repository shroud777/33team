关于树链剖分，主要是理清几个概念：
- 重儿子，轻儿子，重边，轻边，重链等等
- 重儿子；对于每一个非叶子节点，它的儿子中 儿子数量最多的那一个儿子为该节点的重儿子
- 轻儿子：对于每一个非叶子节点，它的儿子中 非重儿子 的剩下所有儿子即为轻儿子
- 叶子节点没有重儿子也没有轻儿子（因为它没有儿子。。）
- 重边：连接任意两个重儿子的边叫做重边
- 轻边：剩下的即为轻边
- 重链：相邻重边连起来的 连接一条重儿子 的链叫重链
对于叶子节点，若其为轻儿子，则有一条以自己为起点的长度为1的链
每一条重链以轻儿子为起点

为了划分重链我们需要做两次 dfs 预处理
第一次 dfs 需要做标记每个点的深度dep，标记每个点的父亲fa，标记每个非叶子节点的子树大小sz(含它自己)，标记每个非叶子节点的重儿子编号son

第二次 dfs 需要做的是处理每一条重链，标记每个点的新编号，并且给每个新编号赋值，处理每条链的顶端
顺序：先处理重儿子再处理轻儿子，这样可以保证一条重链是连续的，我们就可以很方便地用线段树对 dfs 序建树，方便维护每一条树链，同时一个结点的子树编号也是连续的

我们要处理如下问题：
- 1.处理任意两点间路径上的点权和
- 2.处理一点及其子树的点权和
- 3.修改任意两点间路径上的点权
- 4.修改一点及其子树的点权

1.当我们要处理任意两点间路径时：设所在链顶端的深度更深的那个点为x点

- ans加上x点到x所在链顶端 这一段区间的点权和
- 把x跳到x所在链顶端的那个点的上面一个点
- 不停执行这两个步骤，直到两个点处于一条链上，这时再加上此时两个点的区间和即可
- 这时我们注意到，我们所要处理的所有区间均为连续编号(新编号)，每次处理一条重链上的东西，于是想到线段树，用线段树处理连续编号区间和
- 注意！！！！这个过程不像倍增求 lca 是单独一个点往上跳，是每次循环都要找出链顶端的深度更深的点才行
- 注意2！！！！还有就是比较的是每个点所在重链顶端的深度！！顶端的！！不然会导致 RE RE RE，之前就错比较成每个点的深度，然后可能点更深的那个点链顶更浅，导致最后直接跳出树顶，然后线段树维护 [0,0] 导致RE

测试用例如下：

6 1000 1 10000007
1 2 3 4 5 6
1 2
2 3
3 4
1 5
5 6
1 2 4 6

2.处理一点及其子树的点权和：

- 想到记录了每个非叶子节点的子树大小(含它自己)，并且每个子树的新编号都是连续的
- 于是直接线段树区间查询即可
- 时间复杂度为O(logn)O(logn)

3-4.求和和修改思路差不多
