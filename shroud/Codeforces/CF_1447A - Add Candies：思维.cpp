//题意：现在有 n 个背包，第 i 个背包有第 i 个糖果，可以执行 m 次操作，第 i 操作选择一个背包 j，将除 j 外所有背包的糖果数 +i，现在 m 的大小和每次操作对象都由你决定，输出方案

//思路：一道简答的思维题，但是可以还是很不错的，可以从很多方面想
//1.第一个角度来看，1-m 次操作，他对于每个非选中目标糖果的分配是递增的，那么序列就是 1-n 的递增序列，我们肯定想序列越往后的分配的越少，那从前往后开始，第 m 次操作分配 m 个
//我们让最后一个少拿点，那选择最后一个，其他的以此类推，不断向前，然后反过来就是从前向后
//2.可以想到如果舍弃除 j 外的背包的糖果数+1，我们相当于对序列每个数加上 sigma(1-n)，那么现在我们重新恢复题意要求的除 j 外所有的背包，那么第 i 次减去第 j 个背包的 i 个糖果
//同时原序列的特性，让我们很好想到，减去原序列的编号即可，可以看做重复两次

#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

int main(){
	int t;
	cin>>t;
	while(t--){
		int n;
		cin>>n;
		cout<<n<<endl;
		for(int i=1;i<=n;i++) printf("%d%c",i,i==n?'\n':' ');
	}
	return 0;
}
