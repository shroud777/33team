//题意：给出一个长度为 n 的序列，你可以执行不超过 n 次如下操作使序列每个元素相等：选择下标为 i，j，k 的三个元素，并且三个位置的值都变成了这三个元素的异或和，问是否可以得到要求

//思路：首先可以发现一个规律：a^a^b=b
//那么对于两个相等的元素，我们可以用一个不等于他的元素异或他，来扩大相同数的个数
//这样我们想尽量构造这样两两相等的元素，我们可以想到，只要利用异或和三个位置相等的条件，我们每次对 i，i+1，i+2 进行操作，然后每次 i 向后移动两个位置
//然后构造完成后只需要用最后的数，和那两两成对的异或即可
//但是这种情况只适用于奇数，如果偶数的话没法这样构造，如果我们把偶数假设为奇数 + x，那么这个 x 值不能结果任何操作，应该和前面的序列相等
//也就是说 x 和前面的异或和异或应该相等，所以就是整体异或等于 0，这样才能保证前 n-1 个数奇数操作后值与 x 相等

#include <bits/stdc++.h>

using namespace std;

int n;

int main(){
	scanf("%d",&n);
	int temp=0,x;
	for(int i=1;i<=n;i++){
		scanf("%d",&x);
		temp^=x;
	}
	if(temp!=0&&n%2==0){
		puts("NO");
		return 0;
	}
	puts("YES");
	if(n%2==0) n--;
	cout<<n-1<<endl; 
	for(int i=3;i<=n;i+=2) cout<<i-2<<" "<<i-1<<" "<<i<<endl;
	for(int i=2;i<n;i+=2) cout<<i-1<<" "<<i<<" "<<n<<endl;
	return 0;
}
