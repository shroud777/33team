//题意：有一个长度为 n 的序列，现在可以作如下操作：
//选择一个区间 [l,r]，然后将区间内的所有数变成区间内第 (r-l+2)/2 大的数
//问是否可以通过若干次操作将序列全部变成某个数 k？

//思路：这道题首先要明确几个转换关系
//我们要想把整个序列变成 k 的序列，只要序列第中位数大的值是 k 即可，也就是有一半的数比 k 小
//并且对于一个区间 [k,x]，如果 x>=k，那么区间就会变成 [k,k]，所以也就是说，所以大于等于 k 的数都可以看成 k，因为我们都可以转换他
//并且如果序列中大于等于 k 的数已经超过了一半，那么就不用多说了，可以把大于 k 的数变掉即可，使 k 成为中位数
//那么对于其他情况，我们怎么思考呢？我们设大于等于 k 的数为 1，小于 k 的数为 0
//我们要实现上述目标，就是把所有序列超过一半的数变成大于等于 k 的
//那么我们只要找到一个区间内有超过一半的大于等于 k 的数，就可以从整个序列蔓延：
//因为比如 [1 1 0] 这种两个相邻的大于等于 k 的元素，我们可以不断把数字变成 [1 1 1] 每次加入一位，以此类推（注意这里如果新遇到的数是 k，我们不可以用大于 k 的数把他同化，因为我们保证要有 k，所以我们可以继续选择 [x>k,y=k] 同化一个 k）
//并且我们可以发现不仅是上述情况 [1 0 1] 这类的情况也是可以的，依次类推
//所以我们发现只要存在两个距离 j-i<=2 的大于等于 k 的元素并且序列中存在 k 就可以使得满足情况

//另外：两个大于等于 k 的元素相当于导火索，从这里像外扩展，如果遇到小于 k 的就同化，遇到 k 的话 [k,x>k] 就可以变成 [k,k] 然后 2 个 k 和任意元素都可以变成 [k,k,k] 所以满足条件
//多想想就清楚了

#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int maxn=5e5+10;

ll n,k,a[maxn];

int main(){
    int t;
    cin>>t;
    while(t--){
        cin>>n>>k;
        for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
        bool f=0,ff=0,fff=0;
        int cnt=0;
        for(int i=1;i<=n;i++){
            if(a[i]==k) f=1;
            if(a[i]<k) cnt++;
            if(i>1){
                if(a[i]>=k&&a[i-1]>=k) ff=1;
            }
            if(i>2){
                if(a[i]>=k&&a[i-2]>=k) fff=1;
            }
        }
        if(!f){
            puts("NO");
            continue;
        }
        if(fff||ff||cnt<(n-1)/2+1) puts("yes");
        else puts("NO");
    }
    return 0;
}
