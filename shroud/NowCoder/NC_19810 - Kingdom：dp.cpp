//题意：给出一个 n 个结点构成的树，根节点权值位 0 ，重儿子的权值等于根节点的权值，轻儿子的权值等于根节点的权值+1，求构造出来的树权值最大可以达到多少。

//思路：设 n 个结点的树最大权值是 dp[i] ，我们想要构成 n 个结点的树，就要从除根节点外剩下 n-1 个结点形成的最大数大小为 j 的森林找最大值，这里遍历最大树 j 的大小，其他树大小一定不能大于它
//那么dp[n]的值就由这些子树的dp值构成，其中，对于除了重子树的节点，都有额外的权值1，求出轻儿子的贡献同时确保其小于重儿子。这就要求将除重儿子以外的结点分成若干组，每组结点数不能大于j。
//因此，我们再定义：f[i][j] 表示将i个结点分成若干组（每组各有一个根节点）且每组不大于j个时，得到的最大花费。

//由此第一个转移方程便求出来了：dp[i] = max (dp[i] , dp[j]+f[i-j-1][j]+i-j-1)。
//为什么要加上后面“i-j+1”这一串？因为f[i][j]分组后每组实际上是一棵子树.
//现在需要将子树连接到根节点上，由于其为轻儿子（也就是非心腹大臣），自然要在子树的根节点上加一，而后所有子树便都要加一，其大小正好为“i-j+1”。

//第二个转移方程如下：
//f[i][j]= f[i-j][j] + ans[j]; (i>=j)
//f[i][j]= f[i][j-1];          (i<j)

//好难。。。

//f[i][j] 剩余 i 个结点分成x堆（x的值不重要）每一堆的大小不超过 j  
#include <bits/stdc++.h>
using namespace std;
const int maxn=8010;
int dp[maxn],f[maxn][maxn];
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		for(int j=1;j<i;j++){
			dp[i]=max(dp[i],dp[j]+f[i-j-1][j]+i-j-1);
		}
		for(int j=1;j<=n;j++){
			if(i>=j) f[i][j]=f[i-j][j]+dp[j];
			else f[i][j]=f[i][j-1];
		}
	}
	cout<<dp[n]<<endl;
}
