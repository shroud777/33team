//题意：有三种类型的麻将牌 'C','B','D',每张麻将牌有一个类型和序号，每种类型的序号都不同，还有一张白板。
//给出 3*m+1 张麻将牌，从中选出一张幸运牌，然后再选出从所有牌中 n 张麻将牌，并将他们排序，排序规则如下，幸运牌永远在最左，其他牌按照 'C'<'B'<'D' 的顺序排序，相同类型按照序号从小到大
//还有一张白板牌，如何被选到，那么他在牌中安放的顺序与幸运牌之前的地位相同，问在保证至少有一张幸运牌存在的情况下，幸运牌有几种可能？

//思路：首先，我们可以知道，正常情况下，在没有安放幸运牌和白板的情况下，牌序必然是有序的，这种情况下我们可以认为除了第一张可能是幸运牌（虽然他可能不是），其他 n-1 张牌肯定不可能是
//不然他们也不会在顺序的位置上，所以幸运牌可能的存在是 3*m-n-1
//对于只有一张牌的情况，这张牌的牌序位置没有任何信息可以参考，我们只能认定所有 3*m 张牌都可能是幸运牌
//然后来想想，当这种牌序被打破，也就是幸运牌暴露自己的身份，一张本该出现在后面的牌却出现在第一张，那么幸运牌只能是它了
//然后我们来讨论一下白板存在的情况对当前局面的影响，首先，白板代表“不幸运的”幸运牌，意识就是可以确定幸运牌的范围，比如他夹在 a 和 b 中间，那么他就有可能是 a 和 b 之间任意 b-a-2 个值
//但是不能这么宽泛的想，有几个特殊的位置。首先白板出现在最前面，说明当前牌序中没有幸运牌，那么幸运牌可以是比第一张白板后面的第二张牌小的任意卡牌
//如果出现在第二位，他一定是比第三种卡牌的小，但是他不一定比第一张卡牌大，可能第一张卡牌就是幸运牌，所以存在的情况 +1 种

#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
const int maxn=1e5+10;

int n,m;
int a[maxn];

int main(){
	int t;
	scanf("%d",&t);
	while(t--){
		scanf("%d %d",&n,&m);
		char ch[5];
		int p=-1;
		for(int i=1;i<=n;i++){
			scanf("%s",ch);
			if(ch[0]=='W'){
				p=i;continue;
			}
			else{
				scanf("%d",&a[i]);
				if(ch[0]=='B') a[i]+=m;
				else if(ch[0]=='D') a[i]+=2*m; 
			}
		}
		a[n+1]=3*m+1; 
		if(n==1){
			printf("%lld\n",3*m);continue;
		} 
		if(a[2]<a[1]&&p!=2){
			puts("1");continue;
		}
		if(p==-1){
			printf("%lld\n",3*m-n+1);continue;
		}
		if(p==1) printf("%lld\n",a[2]);
		else if(p==2) printf("%lld\n",a[3]-a[1]);
		else printf("%lld\n",a[p+1]-a[p-1]-1);
	}
	return 0;
} 
